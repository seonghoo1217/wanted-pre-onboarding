# Index
- Read의 효율성을 높이기 위해 고려된 자료구조
- B-Tree 구조로 관리된다.

## 순차 I/O vs 랜덤 I/O

- 순차 I/O를 랜덤 I/O로 바꾸기는 어렵다.
- 순차 I/O가 훨씬 빠르다.

## Index를 효율적으로 사용하는 방법
1. Cardinality 
   1. 얼마나 유니크한 값들이 많은지
   2. 만약 성별을 기준으로 인덱스를 걸게된다면 반밖에 거르지 못한다.

2. Update Frequency
   1. 제일 수정이 적은 테이블에 Index를 거는 것
   2. 수정이 적으면서 조회작업이 많이 되는 것
3. Size (인덱스 키 값의 크기)
   1. row 크기,DB에 들어가는 데이터 크기
   2. Pointer : 실제 주소의 사이즈

## 인덱스를 충분히 활용할 수 있도록 쿼리를 작성하는 방법들에 대해 논의

1. Order By
2. Like
3. Between , In

## Normalization
1. 데이터 중복이 어떻게 줄어드는지
2. MySQL이 중복 데이터를 방지할 수 있기 때문
3. 관계형 데이터베이스의 장점

## Partition
- 큰테이블을 소규모의 테이블로 임의로 나누어 저장하는 것
- 하지만 사용자는 하나의 테이블로 read/write 한다고 생각한다.

### Partition 종류
1. Range
   1. 범위 별로 데이터를 나누어 파티션에 저장하는 것
2. List
   1. 카테고리 별로 나누어 파티션에 저장
3. Hash
   1. Range,List로 균등하게 데이터를 나누기 어려운 경우
4. Range-Hash
5. Range-List


## Partitioning vs Sharding
- 쉽게 말하자면 하나의 DB내에서 분산하는 것이 파티션(목적이 같다), 샤딩은 여러개의 DB를 분산하는 것(목적이 다름)

## Cache
- 쿼리의 효율성을 위해 반복되는 Query를 DB에 계속 작업할 경우 서버에 부담이 가기에 좋은 방법이 아니다.
- 그렇기 때문에 메모리에 반복되는 쿼리문을 저장해놓았다가 클라이언트가 재요청시 메모리에서 전달
- 하지만 좋은 방법은 아님, 동시성 문제 또는 수정되었을 경우 동기화 문제가 존재

